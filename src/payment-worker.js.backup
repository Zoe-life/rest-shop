/**
 * Cloudflare Worker - Payment Service Proxy to Node.js Backend
 * 
 * This worker acts as a lightweight edge proxy that forwards payment-related requests
 * to the Node.js backend service where MongoDB/Mongoose operations are handled.
 * 
 * Architecture:
 * - Cloudflare Worker (this file): Edge routing for payment endpoints
 * - Node.js Backend: Payment processing, database operations via Mongoose
 * 
 * This solves the Mongoose incompatibility with Cloudflare Workers runtime
 * by keeping database operations in a proper Node.js environment.
 */

export default {
  async fetch(request, env) {
    const url = new URL(request.url);
    
    // Get the backend URL from environment variable
    const backendUrl = env.BACKEND_API_URL || env.NODE_BACKEND_URL;
    
    if (!backendUrl) {
      return new Response(
        JSON.stringify({
          error: {
            message: 'Backend API URL not configured. Please set BACKEND_API_URL or NODE_BACKEND_URL environment variable.',
            code: 'BACKEND_NOT_CONFIGURED'
          }
        }),
        {
          status: 500,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }

    // Health check endpoint specific to payment service
    if (url.pathname === '/health' || url.pathname === '/payments/health') {
      try {
        const backendHealthUrl = `${backendUrl}/health`;
        const backendResponse = await fetch(backendHealthUrl, {
          method: 'GET',
          headers: {
            'User-Agent': 'Cloudflare-Payment-Worker/1.0'
          }
        });

        const backendHealth = await backendResponse.json();
        
        return new Response(
          JSON.stringify({
            service: 'payment-worker',
            status: 'ok',
            backend: backendHealth,
            timestamp: new Date().toISOString()
          }),
          {
            status: 200,
            headers: { 'Content-Type': 'application/json' }
          }
        );
      } catch (error) {
        return new Response(
          JSON.stringify({
            service: 'payment-worker',
            status: 'ok',
            backend: 'unreachable',
            error: error.message,
            timestamp: new Date().toISOString()
          }),
          {
            status: 503,
            headers: { 'Content-Type': 'application/json' }
          }
        );
      }
    }

    // Build the backend URL with the same path and query string
    const backendTargetUrl = `${backendUrl}${url.pathname}${url.search}`;

    try {
      const headers = new Headers(request.headers);
      
      // Add proxy identification headers
      headers.set('X-Forwarded-By', 'Cloudflare-Payment-Worker');
      headers.set('X-Forwarded-Proto', url.protocol.replace(':', ''));
      headers.set('X-Forwarded-Host', url.host);
      
      // Forward the original IP if available
      const clientIP = request.headers.get('CF-Connecting-IP');
      if (clientIP) {
        headers.set('X-Forwarded-For', clientIP);
        headers.set('X-Real-IP', clientIP);
      }

      // Forward environment secrets as headers
      if (env.JWT_KEY) {
        headers.set('X-JWT-Key', env.JWT_KEY);
      }
      if (env.STRIPE_SECRET_KEY) {
        headers.set('X-Stripe-Secret-Key', env.STRIPE_SECRET_KEY);
      }
      if (env.STRIPE_WEBHOOK_SECRET) {
        headers.set('X-Stripe-Webhook-Secret', env.STRIPE_WEBHOOK_SECRET);
      }
      if (env.PAYPAL_CLIENT_ID) {
        headers.set('X-Paypal-Client-ID', env.PAYPAL_CLIENT_ID);
      }
      if (env.PAYPAL_CLIENT_SECRET) {
        headers.set('X-Paypal-Client-Secret', env.PAYPAL_CLIENT_SECRET);
      }
      if (env.MPESA_CONSUMER_KEY) {
        headers.set('X-Mpesa-Consumer-Key', env.MPESA_CONSUMER_KEY);
      }
      if (env.MPESA_CONSUMER_SECRET) {
        headers.set('X-Mpesa-Consumer-Secret', env.MPESA_CONSUMER_SECRET);
      }
      if (env.ALLOWED_ORIGINS) {
        headers.set('X-Allowed-Origins', env.ALLOWED_ORIGINS);
      }

      // Create forwarded request
      const forwardedRequest = new Request(backendTargetUrl, {
        method: request.method,
        headers: headers,
        body: request.method !== 'GET' && request.method !== 'HEAD' ? request.body : undefined,
        redirect: 'manual'
      });

      // Forward request to backend
      const backendResponse = await fetch(forwardedRequest);

      // Clone response to return to client
      const responseHeaders = new Headers(backendResponse.headers);
      
      // Add headers to indicate this came through the payment worker
      responseHeaders.set('X-Served-By', 'Cloudflare-Payment-Worker');
      responseHeaders.set('X-Backend-Status', backendResponse.status.toString());

      // Return the response from backend
      return new Response(backendResponse.body, {
        status: backendResponse.status,
        statusText: backendResponse.statusText,
        headers: responseHeaders
      });

    } catch (error) {
      console.error('Error proxying payment request to backend:', error);
      
      return new Response(
        JSON.stringify({
          error: {
            message: 'Payment backend service unavailable',
            details: error.message,
            code: 'PAYMENT_BACKEND_ERROR'
          }
        }),
        {
          status: 502,
          headers: { 'Content-Type': 'application/json' }
        }
      );
    }
  }
};
